package internal_test

import (
	"errors"
	"reflect"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/michelin/gochopchop/internal"
	"gopkg.in/yaml.v2"
)

var errStrTypeOf = reflect.TypeOf(errors.New(""))

func checkErr(err, expErr error, t *testing.T) {
	// Check err type
	typeErr := reflect.TypeOf(err)
	typeExpErr := reflect.TypeOf(expErr)
	if typeErr != typeExpErr {
		t.Fatalf("Failed to get expected error type: got \"%s\" instead of \"%s\".", typeErr, typeExpErr)
	}

	// Check Error content is not empty
	if err != nil && err.Error() == "" {
		t.Error("Error should not have an empty content.")
	}

	// Check err fields. Takes the asumption that they are
	// of the same type, thanks to the previous check.
	if typeErr == errStrTypeOf {
		return // Skip following checks for errors generated by errors.New
	}

	switch err.(type) {
	case *internal.ErrNilParameter:
		castedErr := err.(*internal.ErrNilParameter)
		castedExpErr := expErr.(*internal.ErrNilParameter)

		if castedErr.Name != castedExpErr.Name {
			t.Error("Failed to get expected ErrNilParameter.Name: got \"" + castedErr.Name + "\" instead of \"" + castedExpErr.Name + "\".")
		}

	case *internal.ErrUnsupportedSeverity:
		castedErr := err.(*internal.ErrUnsupportedSeverity)
		castedExpErr := expErr.(*internal.ErrUnsupportedSeverity)

		if castedErr.Severity != castedExpErr.Severity {
			t.Errorf("Failed to get expected ErrUnsupportedSeverity.Severity: got \"%d\" instead of \"%d\".", castedErr.Severity, castedExpErr.Severity)
		}

	case *internal.ErrInvalidSeverity:
		castedErr := err.(*internal.ErrInvalidSeverity)
		castedExpErr := expErr.(*internal.ErrInvalidSeverity)

		if castedErr.Severity != castedExpErr.Severity {
			t.Error("Failed to get expected ErrInvalidSeverity.Severity: got \"" + castedErr.Severity + "\" intead of \"" + castedExpErr.Severity + "\".")
		}

	case *internal.ErrInvalidHeaderFormat:
		castedErr := err.(*internal.ErrInvalidHeaderFormat)
		castedExpErr := expErr.(*internal.ErrInvalidHeaderFormat)

		if castedErr.Header != castedExpErr.Header {
			t.Error("Failed to get expected ErrInvalidSeverity.Header: got \"" + castedErr.Header + "\" intead of \"" + castedExpErr.Header + "\".")
		}

	case *internal.ErrInvalidExport:
		castedErr := err.(*internal.ErrInvalidExport)
		castedExpErr := expErr.(*internal.ErrInvalidExport)

		if !cmp.Equal(castedErr.Exports, castedExpErr.Exports) {
			t.Errorf("Failed to get expected ErrInvalidExport.Exports: got \"%v\" instead of \"%v\".", castedErr.Exports, castedExpErr.Exports)
		}

	case *internal.ErrInvalidURLs:
		castedErr := err.(*internal.ErrInvalidURLs)
		castedExpErr := expErr.(*internal.ErrInvalidURLs)

		if !cmp.Equal(castedErr.URLs, castedExpErr.URLs) {
			t.Errorf("Failed to get expected ErrInvalidURLs.URLs: got \"%v\" instead of \"%v\".", castedErr.URLs, castedExpErr.URLs)
		}

	case *internal.ErrFailedOperationOnField:
		castedErr := err.(*internal.ErrFailedOperationOnField)
		castedExpErr := expErr.(*internal.ErrFailedOperationOnField)

		if castedErr.Field != castedExpErr.Field {
			t.Error("Failed to get expected ErrFailedOperationOnField.Field: got \"" + castedErr.Field + "\" instead of \"" + castedExpErr.Field + "\".")
		}
		if castedErr.Operation != castedExpErr.Operation {
			t.Error("Failed to get expected ErrFailedOperationOnField.Operation: got \"" + castedErr.Operation + "\" instead of \"" + castedExpErr.Operation + "\".")
		}
		if castedErr.Value != castedExpErr.Value {
			t.Errorf("Failed to get expected ErrFailedOperationOnField.Value: got \"%d\" instead of \"%d\".", castedErr.Value, castedExpErr.Value)
		}

	case *internal.ErrCheckInvalidField:
		castedErr := err.(*internal.ErrCheckInvalidField)
		castedExpErr := expErr.(*internal.ErrCheckInvalidField)

		if castedErr.Check != castedExpErr.Check {
			t.Error("Failed to get expected ErrFailedOperationOnField.Field: got \"" + castedErr.Check + "\" instead of \"" + castedExpErr.Check + "\".")
		}
		if castedErr.Field != castedExpErr.Field {
			t.Error("Failed to get expected ErrFailedOperationOnField.Field: got \"" + castedErr.Field + "\" instead of \"" + castedExpErr.Field + "\".")
		}

	case *internal.ErrNilFetcher:
		castedErr := err.(*internal.ErrNilFetcher)
		castedExpErr := expErr.(*internal.ErrNilFetcher)

		if castedErr.FetcherName != castedExpErr.FetcherName {
			t.Error("Failed to get expected ErrNilFetcher.Name: got \"" + castedErr.FetcherName + "\" instead of \"" + castedExpErr.FetcherName + "\".")
		}

	case nil, *yaml.TypeError:
		// It's fine there
	default:
		t.Logf("\033[31mcheckErr Unsupported type: %s\033[0m\n", typeErr)
	}
}
